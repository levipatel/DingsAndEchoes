{"ast":null,"code":"export const wrapAudioBufferSourceNodeStartMethodDurationParameter = (nativeAudioScheduledSourceNode, nativeContext) => {\n  let endTime = Number.POSITIVE_INFINITY;\n  let stopTime = Number.POSITIVE_INFINITY;\n\n  nativeAudioScheduledSourceNode.start = ((start, stop) => {\n    return (when = 0, offset = 0, duration = Number.POSITIVE_INFINITY) => {\n      start.call(nativeAudioScheduledSourceNode, when, offset);\n\n      if (duration >= 0 && duration < Number.POSITIVE_INFINITY) {\n        const actualStartTime = Math.max(when, nativeContext.currentTime); // @todo The playbackRate could of course also have been automated and is not always fixed.\n\n        const durationInBufferTime = duration / nativeAudioScheduledSourceNode.playbackRate.value;\n        endTime = actualStartTime + durationInBufferTime;\n        stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n      }\n    };\n  })(nativeAudioScheduledSourceNode.start, nativeAudioScheduledSourceNode.stop);\n\n  nativeAudioScheduledSourceNode.stop = (stop => {\n    return (when = 0) => {\n      stopTime = Math.max(when, nativeContext.currentTime);\n      stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n    };\n  })(nativeAudioScheduledSourceNode.stop);\n};","map":{"version":3,"sources":["../../../src/helpers/wrap-audio-buffer-source-node-start-method-duration-parameter.ts"],"names":[],"mappings":"AAEA,OAAO,MAAM,qDAAqD,GAAG,CACjE,8BADiE,EAEjE,aAFiE,KAG3D;AACN,MAAI,OAAO,GAAG,MAAM,CAAC,iBAArB;AACA,MAAI,QAAQ,GAAG,MAAM,CAAC,iBAAtB;;AAEA,EAAA,8BAA8B,CAAC,KAA/B,GAAuC,CAAC,CAAC,KAAD,EAAQ,IAAR,KAAgB;AACpD,WAAO,CAAC,IAAI,GAAG,CAAR,EAAW,MAAM,GAAG,CAApB,EAAuB,QAAQ,GAAG,MAAM,CAAC,iBAAzC,KAA8D;AACjE,MAAA,KAAK,CAAC,IAAN,CAAW,8BAAX,EAA2C,IAA3C,EAAiD,MAAjD;;AAEA,UAAI,QAAQ,IAAI,CAAZ,IAAiB,QAAQ,GAAG,MAAM,CAAC,iBAAvC,EAA0D;AACtD,cAAM,eAAe,GAAG,IAAI,CAAC,GAAL,CAAS,IAAT,EAAe,aAAa,CAAC,WAA7B,CAAxB,CADsD,CAEtD;;AACA,cAAM,oBAAoB,GAAG,QAAQ,GAAG,8BAA8B,CAAC,YAA/B,CAA4C,KAApF;AAEA,QAAA,OAAO,GAAG,eAAe,GAAG,oBAA5B;AAEA,QAAA,IAAI,CAAC,IAAL,CAAU,8BAAV,EAA0C,IAAI,CAAC,GAAL,CAAS,OAAT,EAAkB,QAAlB,CAA1C;AACH;AACJ,KAZD;AAaH,GAdsC,EAcpC,8BAA8B,CAAC,KAdK,EAcE,8BAA8B,CAAC,IAdjC,CAAvC;;AAgBA,EAAA,8BAA8B,CAAC,IAA/B,GAAsC,CAAE,IAAD,IAAS;AAC5C,WAAO,CAAC,IAAI,GAAG,CAAR,KAAa;AAChB,MAAA,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,IAAT,EAAe,aAAa,CAAC,WAA7B,CAAX;AAEA,MAAA,IAAI,CAAC,IAAL,CAAU,8BAAV,EAA0C,IAAI,CAAC,GAAL,CAAS,OAAT,EAAkB,QAAlB,CAA1C;AACH,KAJD;AAKH,GANqC,EAMnC,8BAA8B,CAAC,IANI,CAAtC;AAOH,CA9BM","sourceRoot":"","sourcesContent":["export const wrapAudioBufferSourceNodeStartMethodDurationParameter = (nativeAudioScheduledSourceNode, nativeContext) => {\n    let endTime = Number.POSITIVE_INFINITY;\n    let stopTime = Number.POSITIVE_INFINITY;\n    nativeAudioScheduledSourceNode.start = ((start, stop) => {\n        return (when = 0, offset = 0, duration = Number.POSITIVE_INFINITY) => {\n            start.call(nativeAudioScheduledSourceNode, when, offset);\n            if (duration >= 0 && duration < Number.POSITIVE_INFINITY) {\n                const actualStartTime = Math.max(when, nativeContext.currentTime);\n                // @todo The playbackRate could of course also have been automated and is not always fixed.\n                const durationInBufferTime = duration / nativeAudioScheduledSourceNode.playbackRate.value;\n                endTime = actualStartTime + durationInBufferTime;\n                stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n            }\n        };\n    })(nativeAudioScheduledSourceNode.start, nativeAudioScheduledSourceNode.stop);\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            stopTime = Math.max(when, nativeContext.currentTime);\n            stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=wrap-audio-buffer-source-node-start-method-duration-parameter.js.map"]},"metadata":{},"sourceType":"module"}