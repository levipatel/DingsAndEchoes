{"ast":null,"code":"import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\n\nconst verifyParameterDescriptors = parameterDescriptors => {\n  if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n    throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n  }\n};\n\nconst verifyProcessorCtor = processorCtor => {\n  if (!isConstructible(processorCtor)) {\n    throw new TypeError('The given value for processorCtor should be a constructor.');\n  }\n\n  if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n    throw new TypeError('The given value for processorCtor should have a prototype.');\n  }\n};\n\nexport const createAddAudioWorkletModule = (createNotSupportedError, evaluateSource, exposeCurrentFrameAndCurrentTime, fetchSource, getBackupNativeContext, getNativeContext, ongoingRequests, resolvedRequests, window) => {\n  return (context, moduleURL, options = {\n    credentials: 'omit'\n  }) => {\n    const nativeContext = getNativeContext(context);\n    const absoluteUrl = new URL(moduleURL, window.location.href).toString(); // Bug #59: Only Chrome & Opera do implement the audioWorklet property.\n\n    if (nativeContext.audioWorklet !== undefined) {\n      return fetchSource(moduleURL).then(source => {\n        const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n        /*\n         * Bug #170: Chrome and Opera do call process() with an array with empty channelData for each input if no input is\n         * connected.\n         *\n         * This is the unminified version of the code used below:\n         *\n         * ```js\n         * `${ importStatements };\n         * ((registerProcessor) => {${ sourceWithoutImportStatements }\n         * })((name, processorCtor) => registerProcessor(name, class extends processorCtor {\n         *\n         *     process (inputs, outputs, parameters) {\n         *         return super.process(\n         *             (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n         *             outputs,\n         *             parameters\n         *         );\n         *     }\n         *\n         * }))`\n         * ```\n         */\n\n        const wrappedSource = `${importStatements};(registerProcessor=>{${sourceWithoutImportStatements}\n})((n,p)=>registerProcessor(n,class extends p{process(i,o,p){return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}))`;\n        const blob = new Blob([wrappedSource], {\n          type: 'application/javascript; charset=utf-8'\n        });\n        const url = URL.createObjectURL(blob);\n        const backupNativeContext = getBackupNativeContext(nativeContext);\n        const nativeContextOrBackupNativeContext = backupNativeContext !== null ? backupNativeContext : nativeContext;\n        return nativeContextOrBackupNativeContext.audioWorklet.addModule(url, options).then(() => URL.revokeObjectURL(url)) // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n        .catch(err => {\n          URL.revokeObjectURL(url);\n\n          if (err.code === undefined || err.name === 'SyntaxError') {\n            err.code = 12;\n          }\n\n          throw err;\n        });\n      });\n    }\n\n    const resolvedRequestsOfContext = resolvedRequests.get(context);\n\n    if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n      return Promise.resolve();\n    }\n\n    const ongoingRequestsOfContext = ongoingRequests.get(context);\n\n    if (ongoingRequestsOfContext !== undefined) {\n      const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n\n      if (promiseOfOngoingRequest !== undefined) {\n        return promiseOfOngoingRequest;\n      }\n    }\n\n    const promise = fetchSource(moduleURL).then(source => {\n      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n      /*\n       * This is the unminified version of the code used below:\n       *\n       * ```js\n       * ${ importStatements };\n       * ((a, b) => {\n       *     (a[b] = a[b] || [ ]).push(\n       *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n       *             ${ sourceWithoutImportStatements }\n       *         }\n       *     );\n       * })(window, '_AWGS');\n       * ```\n       */\n      // tslint:disable-next-line:max-line-length\n\n      const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`; // @todo Evaluating the given source code is a possible security problem.\n\n      return evaluateSource(wrappedSource);\n    }).then(() => {\n      const evaluateAudioWorkletGlobalScope = window._AWGS.pop();\n\n      if (evaluateAudioWorkletGlobalScope === undefined) {\n        throw new SyntaxError();\n      }\n\n      exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {}, undefined, (name, processorCtor) => {\n        if (name.trim() === '') {\n          throw createNotSupportedError();\n        }\n\n        const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n\n        if (nodeNameToProcessorConstructorMap !== undefined) {\n          if (nodeNameToProcessorConstructorMap.has(name)) {\n            throw createNotSupportedError();\n          }\n\n          verifyProcessorCtor(processorCtor);\n          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n          nodeNameToProcessorConstructorMap.set(name, processorCtor);\n        } else {\n          verifyProcessorCtor(processorCtor);\n          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n          NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n        }\n      }, nativeContext.sampleRate, undefined, undefined));\n    }).catch(err => {\n      if (err.code === undefined || err.name === 'SyntaxError') {\n        err.code = 12;\n      }\n\n      throw err;\n    });\n\n    if (ongoingRequestsOfContext === undefined) {\n      ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n    } else {\n      ongoingRequestsOfContext.set(moduleURL, promise);\n    }\n\n    promise.then(() => {\n      const rslvdRqstsFCntxt = resolvedRequests.get(context);\n\n      if (rslvdRqstsFCntxt === undefined) {\n        resolvedRequests.set(context, new Set([moduleURL]));\n      } else {\n        rslvdRqstsFCntxt.add(moduleURL);\n      }\n    }).catch(() => {}) // tslint:disable-line:no-empty\n    // @todo Use finally when it becomes available in all supported browsers.\n    .then(() => {\n      const ngngRqstsFCntxt = ongoingRequests.get(context);\n\n      if (ngngRqstsFCntxt !== undefined) {\n        ngngRqstsFCntxt.delete(moduleURL);\n      }\n    });\n    return promise;\n  };\n};","map":{"version":3,"sources":["../../../src/factories/add-audio-worklet-module.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\nconst verifyParameterDescriptors = (parameterDescriptors) => {\n    if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n    }\n};\nconst verifyProcessorCtor = (processorCtor) => {\n    if (!isConstructible(processorCtor)) {\n        throw new TypeError('The given value for processorCtor should be a constructor.');\n    }\n    if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n        throw new TypeError('The given value for processorCtor should have a prototype.');\n    }\n};\nexport const createAddAudioWorkletModule = (createNotSupportedError, evaluateSource, exposeCurrentFrameAndCurrentTime, fetchSource, getBackupNativeContext, getNativeContext, ongoingRequests, resolvedRequests, window) => {\n    return (context, moduleURL, options = { credentials: 'omit' }) => {\n        const nativeContext = getNativeContext(context);\n        const absoluteUrl = new URL(moduleURL, window.location.href).toString();\n        // Bug #59: Only Chrome & Opera do implement the audioWorklet property.\n        if (nativeContext.audioWorklet !== undefined) {\n            return fetchSource(moduleURL).then((source) => {\n                const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                /*\n                 * Bug #170: Chrome and Opera do call process() with an array with empty channelData for each input if no input is\n                 * connected.\n                 *\n                 * This is the unminified version of the code used below:\n                 *\n                 * ```js\n                 * `${ importStatements };\n                 * ((registerProcessor) => {${ sourceWithoutImportStatements }\n                 * })((name, processorCtor) => registerProcessor(name, class extends processorCtor {\n                 *\n                 *     process (inputs, outputs, parameters) {\n                 *         return super.process(\n                 *             (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n                 *             outputs,\n                 *             parameters\n                 *         );\n                 *     }\n                 *\n                 * }))`\n                 * ```\n                 */\n                const wrappedSource = `${importStatements};(registerProcessor=>{${sourceWithoutImportStatements}\n})((n,p)=>registerProcessor(n,class extends p{process(i,o,p){return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}))`;\n                const blob = new Blob([wrappedSource], { type: 'application/javascript; charset=utf-8' });\n                const url = URL.createObjectURL(blob);\n                const backupNativeContext = getBackupNativeContext(nativeContext);\n                const nativeContextOrBackupNativeContext = backupNativeContext !== null ? backupNativeContext : nativeContext;\n                return (nativeContextOrBackupNativeContext.audioWorklet\n                    .addModule(url, options)\n                    .then(() => URL.revokeObjectURL(url))\n                    // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                    .catch((err) => {\n                    URL.revokeObjectURL(url);\n                    if (err.code === undefined || err.name === 'SyntaxError') {\n                        err.code = 12;\n                    }\n                    throw err;\n                }));\n            });\n        }\n        const resolvedRequestsOfContext = resolvedRequests.get(context);\n        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n            return Promise.resolve();\n        }\n        const ongoingRequestsOfContext = ongoingRequests.get(context);\n        if (ongoingRequestsOfContext !== undefined) {\n            const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n            if (promiseOfOngoingRequest !== undefined) {\n                return promiseOfOngoingRequest;\n            }\n        }\n        const promise = fetchSource(moduleURL)\n            .then((source) => {\n            const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n            /*\n             * This is the unminified version of the code used below:\n             *\n             * ```js\n             * ${ importStatements };\n             * ((a, b) => {\n             *     (a[b] = a[b] || [ ]).push(\n             *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n             *             ${ sourceWithoutImportStatements }\n             *         }\n             *     );\n             * })(window, '_AWGS');\n             * ```\n             */\n            // tslint:disable-next-line:max-line-length\n            const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`;\n            // @todo Evaluating the given source code is a possible security problem.\n            return evaluateSource(wrappedSource);\n        })\n            .then(() => {\n            const evaluateAudioWorkletGlobalScope = window._AWGS.pop();\n            if (evaluateAudioWorkletGlobalScope === undefined) {\n                throw new SyntaxError();\n            }\n            exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {\n            }, undefined, (name, processorCtor) => {\n                if (name.trim() === '') {\n                    throw createNotSupportedError();\n                }\n                const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n                if (nodeNameToProcessorConstructorMap !== undefined) {\n                    if (nodeNameToProcessorConstructorMap.has(name)) {\n                        throw createNotSupportedError();\n                    }\n                    verifyProcessorCtor(processorCtor);\n                    verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                    nodeNameToProcessorConstructorMap.set(name, processorCtor);\n                }\n                else {\n                    verifyProcessorCtor(processorCtor);\n                    verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                    NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n                }\n            }, nativeContext.sampleRate, undefined, undefined));\n        })\n            .catch((err) => {\n            if (err.code === undefined || err.name === 'SyntaxError') {\n                err.code = 12;\n            }\n            throw err;\n        });\n        if (ongoingRequestsOfContext === undefined) {\n            ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n        }\n        else {\n            ongoingRequestsOfContext.set(moduleURL, promise);\n        }\n        promise\n            .then(() => {\n            const rslvdRqstsFCntxt = resolvedRequests.get(context);\n            if (rslvdRqstsFCntxt === undefined) {\n                resolvedRequests.set(context, new Set([moduleURL]));\n            }\n            else {\n                rslvdRqstsFCntxt.add(moduleURL);\n            }\n        })\n            .catch(() => { }) // tslint:disable-line:no-empty\n            // @todo Use finally when it becomes available in all supported browsers.\n            .then(() => {\n            const ngngRqstsFCntxt = ongoingRequests.get(context);\n            if (ngngRqstsFCntxt !== undefined) {\n                ngngRqstsFCntxt.delete(moduleURL);\n            }\n        });\n        return promise;\n    };\n};\n//# sourceMappingURL=add-audio-worklet-module.js.map"]},"metadata":{},"sourceType":"module"}