{"ast":null,"code":"import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n  buffer: null,\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  // Bug #149: Safari does not yet support the detune AudioParam.\n  loop: false,\n  loopEnd: 0,\n  loopStart: 0,\n  playbackRate: 1\n};\nexport const createAudioBufferSourceNodeConstructor = (audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n  return class AudioBufferSourceNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const audioBufferSourceNodeRenderer = isOffline ? createAudioBufferSourceNodeRenderer() : null;\n      super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n      this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n      this._isBufferNullified = false;\n      this._isBufferSet = options.buffer !== null && options.buffer !== undefined;\n      this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n      this._onended = null; // Bug #73: Edge & Safari do not export the correct values for maxValue and minValue.\n\n      this._playbackRate = createAudioParam(this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n    }\n\n    get buffer() {\n      if (this._isBufferNullified) {\n        return null;\n      }\n\n      return this._nativeAudioBufferSourceNode.buffer;\n    }\n\n    set buffer(value) {\n      // Bug #71: Edge does not allow to set the buffer to null.\n      try {\n        this._nativeAudioBufferSourceNode.buffer = value;\n      } catch (err) {\n        if (value !== null || err.code !== 17) {\n          throw err;\n        } // This will modify the buffer in place. Luckily that works in Edge and has the same effect as setting the buffer to null.\n\n\n        if (this._nativeAudioBufferSourceNode.buffer !== null) {\n          const buffer = this._nativeAudioBufferSourceNode.buffer;\n          const numberOfChannels = buffer.numberOfChannels;\n\n          for (let i = 0; i < numberOfChannels; i += 1) {\n            buffer.getChannelData(i).fill(0);\n          }\n\n          this._isBufferNullified = true;\n        }\n      } // Bug #72: Only Chrome, Edge & Opera do not allow to reassign the buffer yet.\n\n\n      if (value !== null) {\n        if (this._isBufferSet) {\n          throw createInvalidStateError();\n        }\n\n        this._isBufferSet = true;\n      }\n    }\n\n    get loop() {\n      return this._nativeAudioBufferSourceNode.loop;\n    }\n\n    set loop(value) {\n      this._nativeAudioBufferSourceNode.loop = value;\n    }\n\n    get loopEnd() {\n      return this._nativeAudioBufferSourceNode.loopEnd;\n    }\n\n    set loopEnd(value) {\n      this._nativeAudioBufferSourceNode.loopEnd = value;\n    }\n\n    get loopStart() {\n      return this._nativeAudioBufferSourceNode.loopStart;\n    }\n\n    set loopStart(value) {\n      this._nativeAudioBufferSourceNode.loopStart = value;\n    }\n\n    get onended() {\n      return this._onended;\n    }\n\n    set onended(value) {\n      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n      this._nativeAudioBufferSourceNode.onended = wrappedListener;\n      const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n      this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n    }\n\n    get playbackRate() {\n      return this._playbackRate;\n    }\n\n    start(when = 0, offset = 0, duration) {\n      this._nativeAudioBufferSourceNode.start(when, offset, duration);\n\n      if (this._audioBufferSourceNodeRenderer !== null) {\n        this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n      } else {\n        setInternalStateToActive(this);\n\n        const resetInternalStateToPassive = () => {\n          this._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive); // @todo Determine a meaningful delay instead of just using one second.\n\n\n          setTimeout(() => setInternalStateToPassive(this), 1000);\n        };\n\n        this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n      }\n    }\n\n    stop(when = 0) {\n      this._nativeAudioBufferSourceNode.stop(when);\n\n      if (this._audioBufferSourceNodeRenderer !== null) {\n        this._audioBufferSourceNodeRenderer.stop = when;\n      }\n    }\n\n  };\n};","map":{"version":3,"sources":["../../../src/factories/audio-buffer-source-node-constructor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    // Bug #149: Safari does not yet support the detune AudioParam.\n    loop: false,\n    loopEnd: 0,\n    loopStart: 0,\n    playbackRate: 1\n};\nexport const createAudioBufferSourceNodeConstructor = (audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n    return class AudioBufferSourceNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const audioBufferSourceNodeRenderer = ((isOffline ? createAudioBufferSourceNodeRenderer() : null));\n            super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n            this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n            this._isBufferNullified = false;\n            this._isBufferSet = options.buffer !== null && options.buffer !== undefined;\n            this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n            this._onended = null;\n            // Bug #73: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._playbackRate = createAudioParam(this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get buffer() {\n            if (this._isBufferNullified) {\n                return null;\n            }\n            return this._nativeAudioBufferSourceNode.buffer;\n        }\n        set buffer(value) {\n            // Bug #71: Edge does not allow to set the buffer to null.\n            try {\n                this._nativeAudioBufferSourceNode.buffer = value;\n            }\n            catch (err) {\n                if (value !== null || err.code !== 17) {\n                    throw err;\n                }\n                // This will modify the buffer in place. Luckily that works in Edge and has the same effect as setting the buffer to null.\n                if (this._nativeAudioBufferSourceNode.buffer !== null) {\n                    const buffer = this._nativeAudioBufferSourceNode.buffer;\n                    const numberOfChannels = buffer.numberOfChannels;\n                    for (let i = 0; i < numberOfChannels; i += 1) {\n                        buffer.getChannelData(i).fill(0);\n                    }\n                    this._isBufferNullified = true;\n                }\n            }\n            // Bug #72: Only Chrome, Edge & Opera do not allow to reassign the buffer yet.\n            if (value !== null) {\n                if (this._isBufferSet) {\n                    throw createInvalidStateError();\n                }\n                this._isBufferSet = true;\n            }\n        }\n        get loop() {\n            return this._nativeAudioBufferSourceNode.loop;\n        }\n        set loop(value) {\n            this._nativeAudioBufferSourceNode.loop = value;\n        }\n        get loopEnd() {\n            return this._nativeAudioBufferSourceNode.loopEnd;\n        }\n        set loopEnd(value) {\n            this._nativeAudioBufferSourceNode.loopEnd = value;\n        }\n        get loopStart() {\n            return this._nativeAudioBufferSourceNode.loopStart;\n        }\n        set loopStart(value) {\n            this._nativeAudioBufferSourceNode.loopStart = value;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeAudioBufferSourceNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n        get playbackRate() {\n            return this._playbackRate;\n        }\n        start(when = 0, offset = 0, duration) {\n            this._nativeAudioBufferSourceNode.start(when, offset, duration);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n            }\n            else {\n                setInternalStateToActive(this);\n                const resetInternalStateToPassive = () => {\n                    this._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n                    // @todo Determine a meaningful delay instead of just using one second.\n                    setTimeout(() => setInternalStateToPassive(this), 1000);\n                };\n                this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeAudioBufferSourceNode.stop(when);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=audio-buffer-source-node-constructor.js.map"]},"metadata":{},"sourceType":"module"}