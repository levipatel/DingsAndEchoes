{"ast":null,"code":"import { interceptConnections } from '../helpers/intercept-connections';\nexport var createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = function createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(createNativeAudioNode) {\n  return function (nativeAudioScheduledSourceNode, nativeContext) {\n    var nativeGainNode = createNativeAudioNode(nativeContext, function (ntvCntxt) {\n      return ntvCntxt.createGain();\n    });\n    nativeAudioScheduledSourceNode.connect(nativeGainNode);\n\n    var disconnectGainNode = function (disconnect) {\n      return function () {\n        // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n        disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n        nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n      };\n    }(nativeAudioScheduledSourceNode.disconnect);\n\n    nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n    interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n\n    nativeAudioScheduledSourceNode.stop = function (stop) {\n      var isStopped = false;\n      return function () {\n        var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n        if (isStopped) {\n          try {\n            stop.call(nativeAudioScheduledSourceNode, when);\n          } catch (_unused) {\n            nativeGainNode.gain.setValueAtTime(0, when);\n          }\n        } else {\n          stop.call(nativeAudioScheduledSourceNode, when);\n          isStopped = true;\n        }\n      };\n    }(nativeAudioScheduledSourceNode.stop);\n  };\n};","map":{"version":3,"sources":["../../../src/factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.ts"],"names":[],"mappings":"AAAA,SAAS,oBAAT,QAAqC,kCAArC;AAGA,OAAO,IAAM,4DAA4D,GAAmE,SAA/H,4DAA+H,CACxI,qBADwI,EAExI;AACA,SAAO,UAAC,8BAAD,EAAiC,aAAjC,EAAkD;AACrD,QAAM,cAAc,GAAG,qBAAqB,CAAC,aAAD,EAAgB,UAAC,QAAD;AAAA,aAAc,QAAQ,CAAC,UAAT,EAAd;AAAA,KAAhB,CAA5C;AAEA,IAAA,8BAA8B,CAAC,OAA/B,CAAuC,cAAvC;;AAEA,QAAM,kBAAkB,GAAI,UAAC,UAAD,EAAe;AACvC,aAAO,YAAK;AACR;AACyC,QAAA,UAAW,CAAC,IAAZ,CAAiB,8BAAjB,EAAiD,cAAjD;AACzC,QAAA,8BAA8B,CAAC,mBAA/B,CAAmD,OAAnD,EAA4D,kBAA5D;AACH,OAJD;AAKH,KAN0B,CAMxB,8BAA8B,CAAC,UANP,CAA3B;;AAQA,IAAA,8BAA8B,CAAC,gBAA/B,CAAgD,OAAhD,EAAyD,kBAAzD;AAEA,IAAA,oBAAoB,CAAC,8BAAD,EAAiC,cAAjC,CAApB;;AAEA,IAAA,8BAA8B,CAAC,IAA/B,GAAuC,UAAC,IAAD,EAAS;AAC5C,UAAI,SAAS,GAAG,KAAhB;AAEA,aAAO,YAAa;AAAA,YAAZ,IAAY,uEAAL,CAAK;;AAChB,YAAI,SAAJ,EAAe;AACX,cAAI;AACA,YAAA,IAAI,CAAC,IAAL,CAAU,8BAAV,EAA0C,IAA1C;AACH,WAFD,CAEE,gBAAM;AACJ,YAAA,cAAc,CAAC,IAAf,CAAoB,cAApB,CAAmC,CAAnC,EAAsC,IAAtC;AACH;AACJ,SAND,MAMO;AACH,UAAA,IAAI,CAAC,IAAL,CAAU,8BAAV,EAA0C,IAA1C;AAEA,UAAA,SAAS,GAAG,IAAZ;AACH;AACJ,OAZD;AAaH,KAhBqC,CAgBnC,8BAA8B,CAAC,IAhBI,CAAtC;AAiBH,GAlCD;AAmCH,CAtCM","sourceRoot":"","sourcesContent":["import { interceptConnections } from '../helpers/intercept-connections';\nexport const createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (createNativeAudioNode) => {\n    return (nativeAudioScheduledSourceNode, nativeContext) => {\n        const nativeGainNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createGain());\n        nativeAudioScheduledSourceNode.connect(nativeGainNode);\n        const disconnectGainNode = ((disconnect) => {\n            return () => {\n                // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n                disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n                nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n            };\n        })(nativeAudioScheduledSourceNode.disconnect);\n        nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n        interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n        nativeAudioScheduledSourceNode.stop = ((stop) => {\n            let isStopped = false;\n            return (when = 0) => {\n                if (isStopped) {\n                    try {\n                        stop.call(nativeAudioScheduledSourceNode, when);\n                    }\n                    catch {\n                        nativeGainNode.gain.setValueAtTime(0, when);\n                    }\n                }\n                else {\n                    stop.call(nativeAudioScheduledSourceNode, when);\n                    isStopped = true;\n                }\n            };\n        })(nativeAudioScheduledSourceNode.stop);\n    };\n};\n//# sourceMappingURL=wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js.map"]},"metadata":{},"sourceType":"module"}