{"ast":null,"code":"import _classCallCheck from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _objectSpread from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nvar DEFAULT_OPTIONS = {\n  channelCount: 2,\n  // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n  channelCountMode: 'explicit',\n  channelInterpretation: 'speakers',\n  numberOfInputs: 1,\n  numberOfOutputs: 1,\n  outputChannelCount: undefined,\n  parameterData: {},\n  processorOptions: {}\n};\n\nvar createChannelCount = function createChannelCount(length) {\n  var channelCount = [];\n\n  for (var i = 0; i < length; i += 1) {\n    channelCount.push(1);\n  }\n\n  return channelCount;\n};\n\nvar sanitizedOptions = function sanitizedOptions(options) {\n  return _objectSpread(_objectSpread({}, options), {}, {\n    outputChannelCount: options.outputChannelCount !== undefined ? options.outputChannelCount : options.numberOfInputs === 1 && options.numberOfOutputs === 1 ?\n    /*\n     * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n     * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n     * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n     */\n    [options.channelCount] : createChannelCount(options.numberOfOutputs)\n  });\n};\n\nexport var createAudioWorkletNodeConstructor = function createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, wrapEventListener) {\n  return /*#__PURE__*/function (_audioNodeConstructor) {\n    _inherits(AudioWorkletNode, _audioNodeConstructor);\n\n    var _super = _createSuper(AudioWorkletNode);\n\n    function AudioWorkletNode(context, name) {\n      var _this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;\n\n      _classCallCheck(this, AudioWorkletNode);\n\n      var nativeContext = getNativeContext(context);\n      var isOffline = isNativeOfflineAudioContext(nativeContext);\n      var mergedOptions = sanitizedOptions(_objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options));\n      var nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n      var processorConstructor = nodeNameToProcessorConstructorMap === undefined ? undefined : nodeNameToProcessorConstructorMap.get(name);\n      var nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n      var audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null;\n      /*\n       * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n       * returns false.\n       */\n\n      _this = _super.call(this, context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n      var parameters = [];\n      nativeAudioWorkletNode.parameters.forEach(function (nativeAudioParam, nm) {\n        var audioParam = createAudioParam(_assertThisInitialized(_this), isOffline, nativeAudioParam);\n        parameters.push([nm, audioParam]);\n      });\n      _this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n      _this._onprocessorerror = null;\n      _this._parameters = new ReadOnlyMap(parameters);\n      /*\n       * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n       * the destination.\n       */\n\n      if (isOffline) {\n        addUnrenderedAudioWorkletNode(nativeContext, _assertThisInitialized(_this));\n      }\n\n      return _this;\n    }\n\n    _createClass(AudioWorkletNode, [{\n      key: \"onprocessorerror\",\n      get: function get() {\n        return this._onprocessorerror;\n      },\n      set: function set(value) {\n        var wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n        this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n        var nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n        this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;\n      }\n    }, {\n      key: \"parameters\",\n      get: function get() {\n        if (this._parameters === null) {\n          // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          return this._nativeAudioWorkletNode.parameters;\n        }\n\n        return this._parameters;\n      }\n    }, {\n      key: \"port\",\n      get: function get() {\n        return this._nativeAudioWorkletNode.port;\n      }\n    }]);\n\n    return AudioWorkletNode;\n  }(audioNodeConstructor);\n};","map":{"version":3,"sources":["../../../src/factories/audio-worklet-node-constructor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    outputChannelCount: undefined,\n    parameterData: {},\n    processorOptions: {}\n};\nconst createChannelCount = (length) => {\n    const channelCount = [];\n    for (let i = 0; i < length; i += 1) {\n        channelCount.push(1);\n    }\n    return channelCount;\n};\nconst sanitizedOptions = (options) => {\n    return {\n        ...options,\n        outputChannelCount: options.outputChannelCount !== undefined\n            ? options.outputChannelCount\n            : options.numberOfInputs === 1 && options.numberOfOutputs === 1\n                ? /*\n                   * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n                   * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n                   * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n                   */\n                    [options.channelCount]\n                : createChannelCount(options.numberOfOutputs)\n    };\n};\nexport const createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, wrapEventListener) => {\n    return class AudioWorkletNode extends audioNodeConstructor {\n        constructor(context, name, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = nodeNameToProcessorConstructorMap === undefined ? undefined : nodeNameToProcessorConstructorMap.get(name);\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n            const audioWorkletNodeRenderer = ((isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null));\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n            const parameters = [];\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n                parameters.push([nm, audioParam]);\n            });\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n             * the destination.\n             */\n            if (isOffline) {\n                addUnrenderedAudioWorkletNode(nativeContext, this);\n            }\n        }\n        get onprocessorerror() {\n            return this._onprocessorerror;\n        }\n        set onprocessorerror(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n            this._onprocessorerror =\n                nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener\n                    ? value\n                    : nativeOnProcessorError;\n        }\n        get parameters() {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return this._nativeAudioWorkletNode.parameters;\n            }\n            return this._parameters;\n        }\n        get port() {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n//# sourceMappingURL=audio-worklet-node-constructor.js.map"]},"metadata":{},"sourceType":"module"}