{"ast":null,"code":"import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, overwriteAccessors) => {\n  return (nativeContext, options) => {\n    const nativeWaveShaperNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createWaveShaper());\n\n    try {\n      // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n      // Bug #119: Safari does not correctly map the values. Bug #102 is only used to detect Safari in this case.\n      nativeWaveShaperNode.curve = new Float32Array([1]);\n      return createNativeWaveShaperNodeFaker(nativeContext, options);\n    } catch {// Ignore errors.\n    }\n\n    assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n    const curve = options.curve; // Bug #104: Chrome will throw an InvalidAccessError when the curve has less than two samples.\n\n    if (curve !== null && curve.length < 2) {\n      throw createInvalidStateError();\n    }\n\n    assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'curve');\n    assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n    let disconnectNativeAudioBufferSourceNode = null;\n    let isConnected = false;\n    overwriteAccessors(nativeWaveShaperNode, 'curve', get => () => get.call(nativeWaveShaperNode), set => value => {\n      set.call(nativeWaveShaperNode, value);\n\n      if (isConnected) {\n        if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n          disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n        } else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n          disconnectNativeAudioBufferSourceNode();\n          disconnectNativeAudioBufferSourceNode = null;\n        }\n      }\n\n      return value;\n    });\n\n    const whenConnected = () => {\n      isConnected = true;\n\n      if (isDCCurve(nativeWaveShaperNode.curve)) {\n        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n      }\n    };\n\n    const whenDisconnected = () => {\n      isConnected = false;\n\n      if (disconnectNativeAudioBufferSourceNode !== null) {\n        disconnectNativeAudioBufferSourceNode();\n        disconnectNativeAudioBufferSourceNode = null;\n      }\n    };\n\n    return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"sources":["../../../src/factories/native-wave-shaper-node-factory.ts"],"names":[],"mappings":"AAAA,SAAS,2BAAT,QAA4C,4CAA5C;AACA,SAAS,4BAAT,QAA6C,6CAA7C;AAGA,OAAO,MAAM,iCAAiC,GAAwC,CAClF,0CADkF,EAElF,uBAFkF,EAGlF,qBAHkF,EAIlF,+BAJkF,EAKlF,SALkF,EAMlF,kBANkF,EAOlF,kBAPkF,KAQlF;AACA,SAAO,CAAC,aAAD,EAAgB,OAAhB,KAA2B;AAC9B,UAAM,oBAAoB,GAAG,qBAAqB,CAAC,aAAD,EAAiB,QAAD,IAAc,QAAQ,CAAC,gBAAT,EAA9B,CAAlD;;AAEA,QAAI;AACA;AACA;AACA,MAAA,oBAAoB,CAAC,KAArB,GAA6B,IAAI,YAAJ,CAAiB,CAAC,CAAD,CAAjB,CAA7B;AAEA,aAAO,+BAA+B,CAAC,aAAD,EAAgB,OAAhB,CAAtC;AACH,KAND,CAME,MAAM,CACJ;AACH;;AAED,IAAA,4BAA4B,CAAC,oBAAD,EAAuB,OAAvB,CAA5B;AAEA,UAAM,KAAK,GAAG,OAAO,CAAC,KAAtB,CAf8B,CAiB9B;;AACA,QAAI,KAAK,KAAK,IAAV,IAAkB,KAAK,CAAC,MAAN,GAAe,CAArC,EAAwC;AACpC,YAAM,uBAAuB,EAA7B;AACH;;AAED,IAAA,2BAA2B,CAAC,oBAAD,EAAuB,OAAvB,EAAgC,OAAhC,CAA3B;AACA,IAAA,2BAA2B,CAAC,oBAAD,EAAuB,OAAvB,EAAgC,YAAhC,CAA3B;AAEA,QAAI,qCAAqC,GAAwB,IAAjE;AACA,QAAI,WAAW,GAAG,KAAlB;AAEA,IAAA,kBAAkB,CACd,oBADc,EAEd,OAFc,EAGb,GAAD,IAAS,MAAM,GAAG,CAAC,IAAJ,CAAS,oBAAT,CAHD,EAIb,GAAD,IAAU,KAAD,IAAU;AACf,MAAA,GAAG,CAAC,IAAJ,CAAS,oBAAT,EAA+B,KAA/B;;AAEA,UAAI,WAAJ,EAAiB;AACb,YAAI,SAAS,CAAC,KAAD,CAAT,IAAoB,qCAAqC,KAAK,IAAlE,EAAwE;AACpE,UAAA,qCAAqC,GAAG,0CAA0C,CAC9E,aAD8E,EAE9E,oBAF8E,CAAlF;AAIH,SALD,MAKO,IAAI,CAAC,SAAS,CAAC,KAAD,CAAV,IAAqB,qCAAqC,KAAK,IAAnE,EAAyE;AAC5E,UAAA,qCAAqC;AACrC,UAAA,qCAAqC,GAAG,IAAxC;AACH;AACJ;;AAED,aAAO,KAAP;AACH,KApBa,CAAlB;;AAuBA,UAAM,aAAa,GAAG,MAAK;AACvB,MAAA,WAAW,GAAG,IAAd;;AAEA,UAAI,SAAS,CAAC,oBAAoB,CAAC,KAAtB,CAAb,EAA2C;AACvC,QAAA,qCAAqC,GAAG,0CAA0C,CAAC,aAAD,EAAgB,oBAAhB,CAAlF;AACH;AACJ,KAND;;AAOA,UAAM,gBAAgB,GAAG,MAAK;AAC1B,MAAA,WAAW,GAAG,KAAd;;AAEA,UAAI,qCAAqC,KAAK,IAA9C,EAAoD;AAChD,QAAA,qCAAqC;AACrC,QAAA,qCAAqC,GAAG,IAAxC;AACH;AACJ,KAPD;;AASA,WAAO,kBAAkB,CAAC,oBAAD,EAAuB,aAAvB,EAAsC,gBAAtC,CAAzB;AACH,GApED;AAqEH,CA9EM","sourceRoot":"","sourcesContent":["import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, overwriteAccessors) => {\n    return (nativeContext, options) => {\n        const nativeWaveShaperNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createWaveShaper());\n        try {\n            // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n            // Bug #119: Safari does not correctly map the values. Bug #102 is only used to detect Safari in this case.\n            nativeWaveShaperNode.curve = new Float32Array([1]);\n            return createNativeWaveShaperNodeFaker(nativeContext, options);\n        }\n        catch {\n            // Ignore errors.\n        }\n        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n        const curve = options.curve;\n        // Bug #104: Chrome will throw an InvalidAccessError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n            throw createInvalidStateError();\n        }\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'curve');\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n        let disconnectNativeAudioBufferSourceNode = null;\n        let isConnected = false;\n        overwriteAccessors(nativeWaveShaperNode, 'curve', (get) => () => get.call(nativeWaveShaperNode), (set) => (value) => {\n            set.call(nativeWaveShaperNode, value);\n            if (isConnected) {\n                if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n                    disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n                }\n                else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n                    disconnectNativeAudioBufferSourceNode();\n                    disconnectNativeAudioBufferSourceNode = null;\n                }\n            }\n            return value;\n        });\n        const whenConnected = () => {\n            isConnected = true;\n            if (isDCCurve(nativeWaveShaperNode.curve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n            }\n        };\n        const whenDisconnected = () => {\n            isConnected = false;\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n        return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-wave-shaper-node-factory.js.map"]},"metadata":{},"sourceType":"module"}