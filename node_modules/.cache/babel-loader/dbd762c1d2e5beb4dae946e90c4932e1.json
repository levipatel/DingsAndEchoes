{"ast":null,"code":"import { filterBuffer } from '../helpers/filter-buffer';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\n\nconst filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {\n  const feedbackLength = feedback.length;\n  const feedforwardLength = feedforward.length;\n  const minLength = Math.min(feedbackLength, feedforwardLength);\n\n  if (feedback[0] !== 1) {\n    for (let i = 0; i < feedbackLength; i += 1) {\n      feedforward[i] /= feedback[0];\n    }\n\n    for (let i = 1; i < feedforwardLength; i += 1) {\n      feedback[i] /= feedback[0];\n    }\n  }\n\n  const bufferLength = 32;\n  const xBuffer = new Float32Array(bufferLength);\n  const yBuffer = new Float32Array(bufferLength);\n  const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);\n  const numberOfChannels = renderedBuffer.numberOfChannels;\n\n  for (let i = 0; i < numberOfChannels; i += 1) {\n    const input = renderedBuffer.getChannelData(i);\n    const output = filteredBuffer.getChannelData(i);\n    xBuffer.fill(0);\n    yBuffer.fill(0);\n    filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);\n  }\n\n  return filteredBuffer;\n};\n\nexport const createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode, createNativeAudioNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n  return (feedback, feedforward) => {\n    const renderedNativeAudioNodes = new WeakMap();\n    let filteredBufferPromise = null;\n\n    const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeAudioBufferSourceNode = null;\n      let nativeIIRFilterNode = getNativeAudioNode(proxy); // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext); // Bug #9: Safari does not support IIRFilterNodes.\n\n      if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n        nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n          buffer: null,\n          channelCount: 2,\n          channelCountMode: 'max',\n          channelInterpretation: 'speakers',\n          loop: false,\n          loopEnd: 0,\n          loopStart: 0,\n          playbackRate: 1\n        });\n      } else if (!nativeIIRFilterNodeIsOwnedByContext) {\n        nativeIIRFilterNode = createNativeAudioNode(nativeOfflineAudioContext, ntvCntxt => {\n          return ntvCntxt.createIIRFilter(feedforward, feedback);\n        });\n      }\n\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode);\n\n      if (nativeAudioBufferSourceNode !== null) {\n        if (filteredBufferPromise === null) {\n          if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n          }\n\n          const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor( // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n          proxy.context.destination.channelCount, // Bug #17: Safari does not yet expose the length.\n          proxy.context.length, nativeOfflineAudioContext.sampleRate);\n\n          filteredBufferPromise = (async () => {\n            await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination, trace);\n            const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);\n            return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);\n          })();\n        }\n\n        const filteredBuffer = await filteredBufferPromise;\n        nativeAudioBufferSourceNode.buffer = filteredBuffer;\n        nativeAudioBufferSourceNode.start(0);\n        return nativeAudioBufferSourceNode;\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode, trace);\n      return nativeIIRFilterNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","map":{"version":3,"sources":["../../../src/factories/iir-filter-node-renderer-factory.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { filterBuffer } from '../helpers/filter-buffer';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {\n    const feedbackLength = feedback.length;\n    const feedforwardLength = feedforward.length;\n    const minLength = Math.min(feedbackLength, feedforwardLength);\n    if (feedback[0] !== 1) {\n        for (let i = 0; i < feedbackLength; i += 1) {\n            feedforward[i] /= feedback[0];\n        }\n        for (let i = 1; i < feedforwardLength; i += 1) {\n            feedback[i] /= feedback[0];\n        }\n    }\n    const bufferLength = 32;\n    const xBuffer = new Float32Array(bufferLength);\n    const yBuffer = new Float32Array(bufferLength);\n    const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);\n    const numberOfChannels = renderedBuffer.numberOfChannels;\n    for (let i = 0; i < numberOfChannels; i += 1) {\n        const input = renderedBuffer.getChannelData(i);\n        const output = filteredBuffer.getChannelData(i);\n        xBuffer.fill(0);\n        yBuffer.fill(0);\n        filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);\n    }\n    return filteredBuffer;\n};\nexport const createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode, createNativeAudioNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (feedback, feedforward) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let filteredBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioBufferSourceNode = null;\n            let nativeIIRFilterNode = getNativeAudioNode(proxy);\n            // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);\n            // Bug #9: Safari does not support IIRFilterNodes.\n            if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n            }\n            else if (!nativeIIRFilterNodeIsOwnedByContext) {\n                nativeIIRFilterNode = createNativeAudioNode(nativeOfflineAudioContext, (ntvCntxt) => {\n                    return ntvCntxt.createIIRFilter(feedforward, feedback);\n                });\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode);\n            if (nativeAudioBufferSourceNode !== null) {\n                if (filteredBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                    // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n                    proxy.context.destination.channelCount, \n                    // Bug #17: Safari does not yet expose the length.\n                    proxy.context.length, nativeOfflineAudioContext.sampleRate);\n                    filteredBufferPromise = (async () => {\n                        await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination, trace);\n                        const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                        return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);\n                    })();\n                }\n                const filteredBuffer = await filteredBufferPromise;\n                nativeAudioBufferSourceNode.buffer = filteredBuffer;\n                nativeAudioBufferSourceNode.start(0);\n                return nativeAudioBufferSourceNode;\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode, trace);\n            return nativeIIRFilterNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=iir-filter-node-renderer-factory.js.map"]},"metadata":{},"sourceType":"module"}