{"ast":null,"code":"import _objectSpread from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { testClonabilityOfAudioWorkletNodeOptions } from '../helpers/test-clonability-of-audio-worklet-node-options';\nexport var createNativeAudioWorkletNodeFactory = function createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioNode, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections) {\n  return function (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) {\n    if (nativeAudioWorkletNodeConstructor !== null) {\n      try {\n        var nativeAudioWorkletNode = createNativeAudioNode(nativeContext, function (ntvCntxt) {\n          return new nativeAudioWorkletNodeConstructor(ntvCntxt, name, options);\n        });\n        var patchedEventListeners = new Map();\n        var onprocessorerror = null;\n        Object.defineProperties(nativeAudioWorkletNode, {\n          /*\n           * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n           * browsers have no native implementation to achieve a consistent behavior.\n           */\n          channelCount: {\n            get: function get() {\n              return options.channelCount;\n            },\n            set: function set() {\n              throw createInvalidStateError();\n            }\n          },\n          channelCountMode: {\n            get: function get() {\n              return 'explicit';\n            },\n            set: function set() {\n              throw createInvalidStateError();\n            }\n          },\n          // Bug #156: Chrome & Opera do not yet fire an ErrorEvent.\n          onprocessorerror: {\n            get: function get() {\n              return onprocessorerror;\n            },\n            set: function set(value) {\n              if (typeof onprocessorerror === 'function') {\n                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n              }\n\n              onprocessorerror = typeof value === 'function' ? value : null;\n\n              if (typeof onprocessorerror === 'function') {\n                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n              }\n            }\n          }\n        });\n\n        nativeAudioWorkletNode.addEventListener = function (addEventListener) {\n          return function () {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            if (args[0] === 'processorerror') {\n              var unpatchedEventListener = typeof args[1] === 'function' ? args[1] : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;\n\n              if (unpatchedEventListener !== null) {\n                var patchedEventListener = patchedEventListeners.get(args[1]);\n\n                if (patchedEventListener !== undefined) {\n                  args[1] = patchedEventListener;\n                } else {\n                  args[1] = function (event) {\n                    unpatchedEventListener(new ErrorEvent(args[0], _objectSpread(_objectSpread({}, event), {}, {\n                      error: new Error()\n                    })));\n                  };\n\n                  patchedEventListeners.set(unpatchedEventListener, args[1]);\n                }\n              }\n            }\n\n            return addEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n          };\n        }(nativeAudioWorkletNode.addEventListener);\n\n        nativeAudioWorkletNode.removeEventListener = function (removeEventListener) {\n          return function () {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n\n            if (args[0] === 'processorerror') {\n              var patchedEventListener = patchedEventListeners.get(args[1]);\n\n              if (patchedEventListener !== undefined) {\n                patchedEventListeners.delete(args[1]);\n                args[1] = patchedEventListener;\n              }\n            }\n\n            return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n          };\n        }(nativeAudioWorkletNode.removeEventListener);\n        /*\n         * Bug #86: Chrome & Opera do not invoke the process() function if the corresponding AudioWorkletNode is unconnected but has\n         * an output.\n         */\n\n\n        if (options.numberOfOutputs !== 0) {\n          var nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n          });\n          nativeAudioWorkletNode.connect(nativeGainNode)\n          /*\n           * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is\n           * used here to make sure to connect the right destination.\n           */\n          .connect(nativeGainNode.context.destination);\n\n          var whenConnected = function whenConnected() {\n            return nativeGainNode.disconnect();\n          };\n          /*\n           * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is\n           * used here to make sure to connect the right destination.\n           */\n\n\n          var whenDisconnected = function whenDisconnected() {\n            return nativeGainNode.connect(nativeGainNode.context.destination);\n          }; // @todo Disconnect the connection when the process() function of the AudioWorkletNode returns false.\n\n\n          return monitorConnections(nativeAudioWorkletNode, whenConnected, whenDisconnected);\n        }\n\n        return nativeAudioWorkletNode;\n      } catch (err) {\n        // Bug #60: Chrome & Opera throw an InvalidStateError instead of a NotSupportedError.\n        if (err.code === 11) {\n          throw createNotSupportedError();\n        }\n\n        throw err;\n      }\n    } // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n\n\n    if (processorConstructor === undefined) {\n      throw createNotSupportedError();\n    }\n\n    testClonabilityOfAudioWorkletNodeOptions(options);\n    return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n  };\n};","map":{"version":3,"sources":["../../../src/factories/native-audio-worklet-node-factory.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { testClonabilityOfAudioWorkletNodeOptions } from '../helpers/test-clonability-of-audio-worklet-node-options';\nexport const createNativeAudioWorkletNodeFactory = (createInvalidStateError, createNativeAudioNode, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections) => {\n    return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) => {\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            try {\n                const nativeAudioWorkletNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n                    return new nativeAudioWorkletNodeConstructor(ntvCntxt, name, options);\n                });\n                const patchedEventListeners = new Map();\n                let onprocessorerror = null;\n                Object.defineProperties(nativeAudioWorkletNode, {\n                    /*\n                     * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n                     * browsers have no native implementation to achieve a consistent behavior.\n                     */\n                    channelCount: {\n                        get: () => options.channelCount,\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    channelCountMode: {\n                        get: () => 'explicit',\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    // Bug #156: Chrome & Opera do not yet fire an ErrorEvent.\n                    onprocessorerror: {\n                        get: () => onprocessorerror,\n                        set: (value) => {\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n                            }\n                            onprocessorerror = typeof value === 'function' ? value : null;\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n                            }\n                        }\n                    }\n                });\n                nativeAudioWorkletNode.addEventListener = ((addEventListener) => {\n                    return (...args) => {\n                        if (args[0] === 'processorerror') {\n                            const unpatchedEventListener = typeof args[1] === 'function'\n                                ? args[1]\n                                : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                                    ? args[1].handleEvent\n                                    : null;\n                            if (unpatchedEventListener !== null) {\n                                const patchedEventListener = patchedEventListeners.get(args[1]);\n                                if (patchedEventListener !== undefined) {\n                                    args[1] = patchedEventListener;\n                                }\n                                else {\n                                    args[1] = (event) => {\n                                        unpatchedEventListener(new ErrorEvent(args[0], { ...event, error: new Error( /* @todo */) }));\n                                    };\n                                    patchedEventListeners.set(unpatchedEventListener, args[1]);\n                                }\n                            }\n                        }\n                        return addEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.addEventListener);\n                nativeAudioWorkletNode.removeEventListener = ((removeEventListener) => {\n                    return (...args) => {\n                        if (args[0] === 'processorerror') {\n                            const patchedEventListener = patchedEventListeners.get(args[1]);\n                            if (patchedEventListener !== undefined) {\n                                patchedEventListeners.delete(args[1]);\n                                args[1] = patchedEventListener;\n                            }\n                        }\n                        return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.removeEventListener);\n                /*\n                 * Bug #86: Chrome & Opera do not invoke the process() function if the corresponding AudioWorkletNode is unconnected but has\n                 * an output.\n                 */\n                if (options.numberOfOutputs !== 0) {\n                    const nativeGainNode = createNativeGainNode(nativeContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'discrete',\n                        gain: 0\n                    });\n                    nativeAudioWorkletNode\n                        .connect(nativeGainNode)\n                        /*\n                         * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is\n                         * used here to make sure to connect the right destination.\n                         */\n                        .connect(nativeGainNode.context.destination);\n                    const whenConnected = () => nativeGainNode.disconnect();\n                    /*\n                     * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is\n                     * used here to make sure to connect the right destination.\n                     */\n                    const whenDisconnected = () => nativeGainNode.connect(nativeGainNode.context.destination);\n                    // @todo Disconnect the connection when the process() function of the AudioWorkletNode returns false.\n                    return monitorConnections(nativeAudioWorkletNode, whenConnected, whenDisconnected);\n                }\n                return nativeAudioWorkletNode;\n            }\n            catch (err) {\n                // Bug #60: Chrome & Opera throw an InvalidStateError instead of a NotSupportedError.\n                if (err.code === 11) {\n                    throw createNotSupportedError();\n                }\n                throw err;\n            }\n        }\n        // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n        if (processorConstructor === undefined) {\n            throw createNotSupportedError();\n        }\n        testClonabilityOfAudioWorkletNodeOptions(options);\n        return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n    };\n};\n//# sourceMappingURL=native-audio-worklet-node-factory.js.map"]},"metadata":{},"sourceType":"module"}