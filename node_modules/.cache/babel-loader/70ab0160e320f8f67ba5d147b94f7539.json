{"ast":null,"code":"export var wrapAudioBufferSourceNodeStartMethodDurationParameter = function wrapAudioBufferSourceNodeStartMethodDurationParameter(nativeAudioScheduledSourceNode, nativeContext) {\n  var endTime = Number.POSITIVE_INFINITY;\n  var stopTime = Number.POSITIVE_INFINITY;\n\n  nativeAudioScheduledSourceNode.start = function (start, stop) {\n    return function () {\n      var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.POSITIVE_INFINITY;\n      start.call(nativeAudioScheduledSourceNode, when, offset);\n\n      if (duration >= 0 && duration < Number.POSITIVE_INFINITY) {\n        var actualStartTime = Math.max(when, nativeContext.currentTime); // @todo The playbackRate could of course also have been automated and is not always fixed.\n\n        var durationInBufferTime = duration / nativeAudioScheduledSourceNode.playbackRate.value;\n        endTime = actualStartTime + durationInBufferTime;\n        stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n      }\n    };\n  }(nativeAudioScheduledSourceNode.start, nativeAudioScheduledSourceNode.stop);\n\n  nativeAudioScheduledSourceNode.stop = function (stop) {\n    return function () {\n      var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      stopTime = Math.max(when, nativeContext.currentTime);\n      stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n    };\n  }(nativeAudioScheduledSourceNode.stop);\n};","map":{"version":3,"sources":["../../../src/helpers/wrap-audio-buffer-source-node-start-method-duration-parameter.ts"],"names":[],"mappings":"AAEA,OAAO,IAAM,qDAAqD,GAAG,SAAxD,qDAAwD,CACjE,8BADiE,EAEjE,aAFiE,EAG3D;AACN,MAAI,OAAO,GAAG,MAAM,CAAC,iBAArB;AACA,MAAI,QAAQ,GAAG,MAAM,CAAC,iBAAtB;;AAEA,EAAA,8BAA8B,CAAC,KAA/B,GAAwC,UAAC,KAAD,EAAQ,IAAR,EAAgB;AACpD,WAAO,YAA8D;AAAA,UAA7D,IAA6D,uEAAtD,CAAsD;AAAA,UAAnD,MAAmD,uEAA1C,CAA0C;AAAA,UAAvC,QAAuC,uEAA5B,MAAM,CAAC,iBAAqB;AACjE,MAAA,KAAK,CAAC,IAAN,CAAW,8BAAX,EAA2C,IAA3C,EAAiD,MAAjD;;AAEA,UAAI,QAAQ,IAAI,CAAZ,IAAiB,QAAQ,GAAG,MAAM,CAAC,iBAAvC,EAA0D;AACtD,YAAM,eAAe,GAAG,IAAI,CAAC,GAAL,CAAS,IAAT,EAAe,aAAa,CAAC,WAA7B,CAAxB,CADsD,CAEtD;;AACA,YAAM,oBAAoB,GAAG,QAAQ,GAAG,8BAA8B,CAAC,YAA/B,CAA4C,KAApF;AAEA,QAAA,OAAO,GAAG,eAAe,GAAG,oBAA5B;AAEA,QAAA,IAAI,CAAC,IAAL,CAAU,8BAAV,EAA0C,IAAI,CAAC,GAAL,CAAS,OAAT,EAAkB,QAAlB,CAA1C;AACH;AACJ,KAZD;AAaH,GAdsC,CAcpC,8BAA8B,CAAC,KAdK,EAcE,8BAA8B,CAAC,IAdjC,CAAvC;;AAgBA,EAAA,8BAA8B,CAAC,IAA/B,GAAuC,UAAC,IAAD,EAAS;AAC5C,WAAO,YAAa;AAAA,UAAZ,IAAY,uEAAL,CAAK;AAChB,MAAA,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,IAAT,EAAe,aAAa,CAAC,WAA7B,CAAX;AAEA,MAAA,IAAI,CAAC,IAAL,CAAU,8BAAV,EAA0C,IAAI,CAAC,GAAL,CAAS,OAAT,EAAkB,QAAlB,CAA1C;AACH,KAJD;AAKH,GANqC,CAMnC,8BAA8B,CAAC,IANI,CAAtC;AAOH,CA9BM","sourceRoot":"","sourcesContent":["export const wrapAudioBufferSourceNodeStartMethodDurationParameter = (nativeAudioScheduledSourceNode, nativeContext) => {\n    let endTime = Number.POSITIVE_INFINITY;\n    let stopTime = Number.POSITIVE_INFINITY;\n    nativeAudioScheduledSourceNode.start = ((start, stop) => {\n        return (when = 0, offset = 0, duration = Number.POSITIVE_INFINITY) => {\n            start.call(nativeAudioScheduledSourceNode, when, offset);\n            if (duration >= 0 && duration < Number.POSITIVE_INFINITY) {\n                const actualStartTime = Math.max(when, nativeContext.currentTime);\n                // @todo The playbackRate could of course also have been automated and is not always fixed.\n                const durationInBufferTime = duration / nativeAudioScheduledSourceNode.playbackRate.value;\n                endTime = actualStartTime + durationInBufferTime;\n                stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n            }\n        };\n    })(nativeAudioScheduledSourceNode.start, nativeAudioScheduledSourceNode.stop);\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            stopTime = Math.max(when, nativeContext.currentTime);\n            stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=wrap-audio-buffer-source-node-start-method-duration-parameter.js.map"]},"metadata":{},"sourceType":"module"}